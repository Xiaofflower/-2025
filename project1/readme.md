
### **1. 总体结构**

* **基础 SM4 算法实现**
* **T-table 优化**
* **AES-NI 指令集优化**
* **GFNI / VPROLD 指令集的进一步优化**
* **SM4-GCM 模式支持**


### **2. 基础实现**

1. 将输入的 128 位数据分成 4 个 32 位字。
2. 在每轮中使用 S-box 对输入进行非线性变换。
3. 执行线性变换（移位与异或组合）。
4. 按照 SM4 轮函数 `F` 公式更新数据。


### **3. T-table 优化**

* **预计算** S-box + 线性变换的组合结果，存储在 4 个 256 元素的查找表中（每个表对应一个字节位置）。
* 每轮加密时，直接查表并异或组合，而不是逐步做 S-box 和移位运算。

优点：

* 将复杂的字节替换 + 线性变换合并为**一次查表**。
* 显著减少指令数量，提高性能。

代价：

* 内存占用增加（4KB 表）。
* 对缓存友好性有一定要求。


### **4. AES-NI 优化**

虽然 AES-NI 是为 AES 设计的，但某些指令（如 `AESENC`）可以被改造用来加速 SM4：

* 利用 AES-NI 中的字节替换和移位指令模拟 SM4 S-box 和轮函数。
* 通过寄存器操作减少访存次数。

特点：

* 性能提升明显（尤其是 Intel/AMD x86\_64）。
* 对 CPU 架构有依赖，**需要运行时检测支持**。


### **5. GFNI / VPROLD 最新指令集优化**

最新 CPU（如 Intel Ice Lake、AMD Zen 3+）支持：

* **GFNI（Galois Field New Instructions）**：加速有限域 GF(2^8) 和 GF(2^128) 运算。
* **VPROLD**：可一次性对 128/256/512 位寄存器进行循环移位，极大减少位操作指令数。

在 SM4 中，这些指令可用于：

* **GFNI**：加速 SM4-GCM 中的 GF(2^128) 乘法运算（Galois/Counter Mode 核心）。
* **VPROLD**：在轮函数中快速实现循环移位，减少单字节/单字的移位指令。



### **6. SM4-GCM 模式实现**

GCM 模式在加密的同时提供认证（AEAD），依赖两个核心过程：

1. **CTR 模式加密**（使用 SM4 分组加密作为 PRF）。
2. **GHASH 认证**（基于 GF(2^128) 多项式乘法）。

优化思路：

* CTR 计数器部分可利用**并行加密流水线**，减少延迟。
* GHASH 部分使用 GFNI 指令加速乘法。
* 如果无 GFNI，则使用查表或 Karatsuba 分解法优化。



